<!DOCTYPE html>
<html>
    <div id="player"></div>
    <script src="/socket.io/socket.io.js"></script>
    <script>
        const socket = io();
        var tag = document.createElement('script');
        tag.src = "https://www.youtube.com/iframe_api";
        var firstScriptTag = document.getElementsByTagName('script')[0];
        firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);

        var player;
        let pulseInterval;
        let lastSpeed = 1;

        function onYouTubeIframeAPIReady() {
            player = new YT.Player('player', {
                height: '315',
                width: '560',
                videoId: 'RzVvThhjAKw', //Mettre une variable avec cette partie de l'URL de la vidéo selon la vidéo choisie
                playerVars: {
                    'autoplay': 1,
                    "mute" : 1
                },
                events: {
                    'onStateChange': onPlayerStateChange,
                    'onPlaybackRateChange' : onPlaybackRateChange
                }
            });
        }

        let isSyncing = false;

        function onPlaybackRateChange(event){
            if (isSyncing) return;
            const newSpeed = event.data;
            socket.emit('changeSpeed', newSpeed);
        }

        function onPlayerStateChange(event) {
            if (isSyncing) return;

            // Sync quand Play ou déplacement
            if (event.data == YT.PlayerState.PLAYING) {
                socket.emit('play'); // Play pour tous les users
                
                // Envoi du temps de la vidéo et de l'heure d'envoi de la commande pour sync (pour sync selon la dernier mouvement)
                socket.emit('syncAction', {
                    videoTime: player.getCurrentTime(),
                    clockTime: Date.now()
                });

                // Démarrer le "pulse" pour donner notre progression au server (pour les new users)
                pulseInterval = setInterval(() => {
                    socket.emit('videoTime', {
                        videoTime: player.getCurrentTime(),
                        clockTime: Date.now(),
                        playbackRate: player.getPlaybackRate() 
                    });
                }, 5000); // Mise à jour toutes les 5 secondes
            } 
            else if (event.data == YT.PlayerState.PAUSED) {
                socket.emit('pause');
                clearInterval(pulseInterval); // Arrêter le pulse lorsque la vidéo est en pause
            }
        }

        // Sync initial (rejoindre une vidéo en plein milieu)
        socket.on('initialSync', (data) => {
            const checkReady = setInterval(() => {
                if (player && typeof player.seekTo === 'function') {
                    clearInterval(checkReady);
                    
                    let targetTime = data.videoTime;
                    if (data.isPlaying) {
                        // Calcul du temps écoulé depuis la maj serv selon l'heure d'envoi, l'heure actuel et la vitesse de la vidéo
                        const elapsedSinceUpdate = (Date.now() - data.clockTime) / 1000;
                        targetTime += (elapsedSinceUpdate * data.playbackRate);
                    }

                    isSyncing = true;
                    player.setPlaybackRate(data.playbackRate);
                    player.seekTo(targetTime, true);
                    if (data.isPlaying) player.playVideo();
                    else player.pauseVideo();

                    setTimeout(() => isSyncing = false, 1000);
                }
            }, 200);
        });

        // Gestion speed
        socket.on('changeSpeed', (speed) => {
            isSyncing = true;
            player.setPlaybackRate(speed);
            // On refait une sync pour être sûr que tt le monde à la mm speed et est au mm moment de la vidéo
            setTimeout(() => isSyncing = false, 500);
        })

        // Gestion play / pause
        socket.on('play', () => {
            if (player.getPlayerState() !== YT.PlayerState.PLAYING) {
                isSyncing = true;
                player.playVideo();
                setTimeout(() => isSyncing = false, 500);
            }
        });

        socket.on('pause', () => {
            isSyncing = true;
            player.pauseVideo();
            setTimeout(() => isSyncing = false, 500);
        });

        // Synchronisation avec seek
        socket.on('syncAction', (data) => {
            const now = Date.now();
            const currentRate = player.getPlaybackRate();
            // Calcul du lag réseau pour compenser
            const timePassedSinceAction = (now - data.clockTime) / 1000;
            const adjustedTargetTime = data.videoTime + (timePassedSinceAction * currentRate);

            const drift = Math.abs(player.getCurrentTime() - adjustedTargetTime);

            // Gestion d'erreur de sync lié au délais d'envoi du temps et du délais de sync
            // Le seuil de 1.5s est plus sûr que 0.5s pour éviter le jittering.
            if (drift > 1.5) { 
                isSyncing = true;
                player.seekTo(adjustedTargetTime, true);
                
                // Bloquer le signal pendant 800ms pour éviter le problème de "vas et viens" qui était présent avant
                setTimeout(() => isSyncing = false, 800);
            }
        });
    </script>
</html>